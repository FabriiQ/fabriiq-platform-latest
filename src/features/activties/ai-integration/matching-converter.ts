'use client';

import { 
  MatchingActivity, 
  MatchingQuestion, 
  MatchingPair,
  createMatchingPair
} from '../models/matching';
import { generateId } from '../models/base';

/**
 * Convert AI-generated content to a Matching activity
 * 
 * This function handles various formats of AI-generated content and
 * converts them to our standardized activity format.
 * 
 * @param aiContent The AI-generated content
 * @returns A properly formatted MatchingActivity
 */
export function convertAIContentToMatchingActivity(aiContent: any): MatchingActivity {
  console.log('Converting AI content to matching activity:', aiContent);
  
  // Extract questions from AI content (handle different possible structures)
  const questions = aiContent.questions || 
                   aiContent.content?.questions || 
                   aiContent.config?.questions || 
                   [];
  
  // Convert to our standardized format
  return {
    id: aiContent.id || generateId(),
    title: aiContent.title || 'AI Generated Matching Activity',
    description: aiContent.description || 'This matching activity was generated by AI',
    instructions: aiContent.instructions || 'Match each item on the left with its corresponding item on the right.',
    activityType: 'matching',
    
    // Convert questions with explanations and hints
    questions: questions.map((q: any) => {
      // Handle different possible formats for pairs
      let pairs: MatchingPair[] = [];
      
      // If the AI provided pairs in a structured format
      if (q.pairs && Array.isArray(q.pairs)) {
        pairs = q.pairs.map((p: any) => ({
          id: p.id || generateId(),
          leftItem: {
            id: p.leftItem?.id || generateId(),
            text: p.leftItem?.text || p.left || '',
            media: p.leftItem?.media || undefined
          },
          rightItem: {
            id: p.rightItem?.id || generateId(),
            text: p.rightItem?.text || p.right || '',
            media: p.rightItem?.media || undefined
          },
          feedback: p.feedback || `${p.leftItem?.text || p.left} is correctly matched with ${p.rightItem?.text || p.right}.`
        }));
      } 
      // If the AI provided matches as separate arrays
      else if (q.leftItems && Array.isArray(q.leftItems) && q.rightItems && Array.isArray(q.rightItems)) {
        // Ensure the arrays are the same length
        const minLength = Math.min(q.leftItems.length, q.rightItems.length);
        
        for (let i = 0; i < minLength; i++) {
          const leftText = typeof q.leftItems[i] === 'string' ? q.leftItems[i] : q.leftItems[i].text || '';
          const rightText = typeof q.rightItems[i] === 'string' ? q.rightItems[i] : q.rightItems[i].text || '';
          
          pairs.push(createMatchingPair(leftText, rightText));
        }
      }
      // If the AI provided matches as an object with key-value pairs
      else if (q.matches && typeof q.matches === 'object') {
        for (const [left, right] of Object.entries(q.matches)) {
          pairs.push(createMatchingPair(left, right as string));
        }
      }
      
      return {
        id: q.id || generateId(),
        text: q.text || q.question || 'Match the following items',
        pairs: pairs,
        explanation: q.explanation || q.reasoning || '',
        hint: q.hint || '',
        points: q.points || pairs.length,
        partialCredit: q.partialCredit !== undefined ? q.partialCredit : true
      };
    }),
    
    // Settings
    settings: {
      shuffleQuestions: aiContent.shuffleQuestions || false,
      shuffleItems: aiContent.shuffleItems !== undefined ? aiContent.shuffleItems : true,
      showFeedbackImmediately: aiContent.showFeedbackImmediately || true,
      showCorrectAnswers: aiContent.showCorrectAnswers || true,
      passingPercentage: aiContent.passingPercentage || 60,
      attemptsAllowed: aiContent.attemptsAllowed || 1,
      allowPartialCredit: aiContent.allowPartialCredit !== undefined ? aiContent.allowPartialCredit : true
    },
    
    // Metadata for AI-generated content
    metadata: {
      aiGenerated: true,
      generationPrompt: aiContent.prompt || '',
      difficulty: aiContent.difficulty || 'medium',
      estimatedTime: aiContent.estimatedTime || 10,
      keywords: aiContent.keywords || [],
      learningObjectives: aiContent.learningObjectives || []
    },
    
    createdAt: new Date(),
    updatedAt: new Date()
  };
}

/**
 * Enhance an existing activity with AI-generated content
 * 
 * This function takes an existing activity and enhances it with
 * AI-generated content, such as explanations, hints, and feedback.
 * 
 * @param activity The existing activity
 * @param aiContent The AI-generated enhancements
 * @returns The enhanced activity
 */
export function enhanceMatchingActivityWithAI(
  activity: MatchingActivity, 
  aiContent: any
): MatchingActivity {
  // Create a deep copy of the activity
  const enhancedActivity = JSON.parse(JSON.stringify(activity)) as MatchingActivity;
  
  // Enhance activity-level properties if they don't exist
  if (!enhancedActivity.description && aiContent.description) {
    enhancedActivity.description = aiContent.description;
  }
  
  if (!enhancedActivity.instructions && aiContent.instructions) {
    enhancedActivity.instructions = aiContent.instructions;
  }
  
  // Enhance questions
  if (aiContent.questions && Array.isArray(aiContent.questions)) {
    // Match questions by index or ID if possible
    enhancedActivity.questions.forEach((question, index) => {
      const aiQuestion = aiContent.questions[index];
      if (!aiQuestion) return;
      
      // Add explanation if it doesn't exist
      if (!question.explanation && aiQuestion.explanation) {
        question.explanation = aiQuestion.explanation;
      }
      
      // Add hint if it doesn't exist
      if (!question.hint && aiQuestion.hint) {
        question.hint = aiQuestion.hint;
      }
      
      // Enhance pairs with feedback
      if (aiQuestion.pairs && Array.isArray(aiQuestion.pairs)) {
        question.pairs.forEach((pair, pairIndex) => {
          const aiPair = aiQuestion.pairs[pairIndex];
          if (!aiPair) return;
          
          // Add feedback if it doesn't exist
          if (!pair.feedback && aiPair.feedback) {
            pair.feedback = aiPair.feedback;
          }
        });
      }
    });
  }
  
  // Update metadata
  enhancedActivity.metadata = {
    ...enhancedActivity.metadata,
    aiGenerated: true,
    updatedByAI: true,
    lastAIUpdateTime: new Date().toISOString()
  };
  
  // Update timestamp
  enhancedActivity.updatedAt = new Date();
  
  return enhancedActivity;
}

/**
 * Generate AI prompts for activity enhancement
 * 
 * This function generates prompts that can be sent to AI services
 * to enhance different aspects of an activity.
 * 
 * @param activity The activity to enhance
 * @param aspect The aspect to enhance (explanations, hints, feedback)
 * @returns A prompt for the AI service
 */
export function generateMatchingEnhancementPrompt(
  activity: MatchingActivity,
  aspect: 'explanations' | 'hints' | 'feedback'
): string {
  const title = activity.title;
  const description = activity.description || '';
  
  let prompt = '';
  
  switch (aspect) {
    case 'explanations':
      prompt = `Please generate detailed explanations for the following matching questions about "${title}". ${description}\n\n`;
      activity.questions.forEach((q, i) => {
        prompt += `Question ${i+1}: ${q.text}\n`;
        prompt += 'Matching pairs:\n';
        q.pairs.forEach((p, j) => {
          prompt += `- ${p.leftItem.text} → ${p.rightItem.text}\n`;
        });
        prompt += `Please provide a detailed explanation for why these matches are correct.\n\n`;
      });
      break;
      
    case 'hints':
      prompt = `Please generate helpful hints for the following matching questions about "${title}". ${description}\n\n`;
      activity.questions.forEach((q, i) => {
        prompt += `Question ${i+1}: ${q.text}\n`;
        prompt += 'Items to match:\n';
        prompt += 'Left items: ' + q.pairs.map(p => p.leftItem.text).join(', ') + '\n';
        prompt += 'Right items: ' + q.pairs.map(p => p.rightItem.text).join(', ') + '\n';
        prompt += `Please provide a hint that guides the student without giving away the matches.\n\n`;
      });
      break;
      
    case 'feedback':
      prompt = `Please generate specific feedback for each matching pair in the following questions about "${title}". ${description}\n\n`;
      activity.questions.forEach((q, i) => {
        prompt += `Question ${i+1}: ${q.text}\n`;
        q.pairs.forEach((p, j) => {
          prompt += `Pair ${j+1}: ${p.leftItem.text} → ${p.rightItem.text}\n`;
          prompt += `Please provide specific feedback explaining why this match is correct.\n`;
        });
        prompt += '\n';
      });
      break;
  }
  
  return prompt;
}
